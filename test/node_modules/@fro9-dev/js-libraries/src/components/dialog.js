import { toHTML, getElement, dataSetToObject } from "../util/dom-util";
import { confineTab } from "../util/a11y";
import EventHandler from "../_dependencyvendor/event-handler";
import UI from "./ui-base";

// eslint-disable-next-line no-unused-vars
const VERSION = "2.0.0";
const NAME = "ui.dialog";

const IDENTIFIER = {
  ARIA_TRIGGER: "aria-haspopup",
  TRIGGER: "data-dialog-trigger",
  CLOSE: "data-dialog-close",
};

const dataAttrConfig = {
  openClass: "open",
  closeClass: "close",
  bg: true,
  bgclose: false,
  animate: true,
  destroy: false,
};

const defaultConfig = {
  ...dataAttrConfig,
  preventBodyScroll: true,
  bgTemplate: `
    <div style="
      position: fixed; 
      width: 100%; 
      height: 100%;
      left: 0;
      top: 0;
      background-color: rgba(0,0,0,0.6);">
    </div>`,
};

const ZINDEX = {
  CONTENT: 101,
  BACKDROP: 100,
  INCREASE: 1,
};

class Dialog extends UI {
  constructor(element, config = {}) {
    super(element, config);
    this._setupConfog(config);
    this._bg = null;
    this._closeButtons = null;
    this._isOpen = false;
    this._confineTab = null;
    this._init();
    EventHandler.trigger(this._element, Dialog.EVENT.INIT, {
      component: this,
    });
    EventHandler.trigger(document, Dialog.EVENT.ALL, {
      component: this,
      eventType: Dialog.EVENT.INIT,
    });
  }

  static get EVENT() {
    return {
      INIT: `init.${NAME}`,
      OPEN: `open.${NAME}`,
      OPENED: `opened.${NAME}`,
      CLOSE: `close.${NAME}`,
      CLOSED: `closed.${NAME}`,
      ALL: `eventAll.${NAME}`,
      FIRST_OPEN: `firstOpen.${NAME}`,
      LAST_CLOSE: `lastClose.${NAME}`,
    };
  }

  /**
   * 글로벌 설정은 처음에..
   */
  static GLOBAL_OPTIONS = {};
  static PREVENT_BODY_SCROLL = {};

  static _dataName = "dialog";
  static set DATA_NAME(value) {
    _dataName = value;
    IDENTIFIER.TRIGGER = `data-${_dataName}-trigger`;
    IDENTIFIER.CLOSE = `data-${_dataName}-close`;
  }

  static COUNT = 0;
  static SCROLL_POY = 0;

  /**
   * 다이얼로그 객체 반환
   * 인스턴스 반환
   * @param {*} element 다이얼로그 엘리먼트
   * @param {*} initialize 초기화되지 않은 대상에 대해서 초기화 후 인스턴스를 반환할지 여부
   * @returns
   */
  static get(element, initialize = false) {
    let instance = Dialog.getInstance(element);
    if (!instance && initialize) instance = new Dialog(element);
    return instance;
  }

  /**
   * 현재 활성화 되어있는 dialog 모두 닫기
   */
  static closeAll() {
    const instances = Dialog.getInstances();
    for (const p in instances) {
      if (Object.prototype.hasOwnProperty.call(instances, p)) {
        const dialog = instances[p];
        if (dialog) dialog.close();
      }
    }
  }

  static get NAME() {
    return NAME;
  }

  open() {
    this._open();
  }

  close(e) {
    this._close(e);
  }

  /**
   * 다이얼로그를 닫거나 삭제처리 하지 않고
   * 다이얼로그의 컨텐츠만 새로 그려서 사용할 경우
   * 기존의 이벤트나 기타 처리를 모두 초기화 하고
   * 새로 그려진 엘리먼트에 새로 적용한다.
   */
  redraw() {
    // 기존의 탭 시퀀스 처리를 삭제
    this._confineTab.destroy();
    // 기존의 엘리먼틔 이벤트를 삭제
    this._removeEvents();
    // 기존의 엘리먼트를 근거로 저장했던 변수를 삭제
    this._removeVars(true);

    // 새로 그려진 엘리먼트를 기준으로 변수 초기화
    this._initVars();
    // 새로 그려진 엘리먼트에 이벤트 바인딩( 닫기 버튼 등.. )
    this._initEvents();

    // 새로 그려진 엘리먼트의 탭 시퀀스 처리를 초기화
    const tabInfo = this._confineTab.init();
    // 포커싱 처리.
    if (tabInfo && tabInfo.length > 0) tabInfo[0].focus();
  }

  destroy() {
    this._removeEvents();
    this._removeVars();
    this._isOpen = false;
    if (this._options.destroy === true || this._options.destroy === "true") {
      this._element.parentNode.removeChild(this._element);
      super.destroy();
    }

    Dialog.COUNT--;

    EventHandler.trigger(this._element, Dialog.EVENT.CLOSED, {
      component: this,
    });

    EventHandler.trigger(document, Dialog.EVENT.ALL, {
      component: this,
      eventType: Dialog.EVENT.CLOSED,
    });

    if (Dialog.COUNT <= 0) {
      if (Dialog.PREVENT_BODY_SCROLL.close) {
        Dialog.PREVENT_BODY_SCROLL.close();
      }

      EventHandler.trigger(document, Dialog.EVENT.LAST_CLOSE);
      EventHandler.trigger(document, Dialog.EVENT.ALL, {
        component: this,
        eventType: Dialog.EVENT.LAST_CLOSE,
      });
    }
  }

  getElement() {
    return this._element;
  }

  _setupConfog(config) {
    this._options = {
      ...defaultConfig,
      ...Dialog.GLOBAL_OPTIONS,
      ...config,
      ...dataSetToObject(this._element, dataAttrConfig, Dialog._dataName),
    };
  }

  _init() {
    this._element.setAttribute("aria-modal", "true");
  }

  _initVars() {
    this._confineTab = confineTab(this._element);
    this._bg = this._options.bg ? this._createBackground() : null;
    this._closeButtons = this._element.querySelectorAll(`[${IDENTIFIER.CLOSE}]`);
  }

  _initEvents() {
    this._closeButtons.forEach((el) => {
      EventHandler.one(el, super._eventName("click"), this._close.bind(this));
    });
  }

  _removeEvents() {
    if (this._closeButtons) {
      this._closeButtons.forEach((el) => {
        EventHandler.off(el, super._eventName("click"));
      });
    }
  }

  _removeVars(redraw = false) {
    if (redraw === false) {
      this._bg = null;
    }
    this._closeButtons = null;
  }

  _createBackground() {
    if (this._bg) return this._bg;
    return toHTML(this._options.bgTemplate);
  }

  _zIndexOrderIncrease() {
    this._element.style.zIndex = ZINDEX.CONTENT += ZINDEX.INCREASE;
    if (this._bg) this._bg.style.zIndex = ZINDEX.BACKDROP += ZINDEX.INCREASE;
  }

  _open() {
    if (this._isOpen === true) return;
    this._initVars();
    this._initEvents();
    this._zIndexOrderIncrease();
    this._showBackground();
    this._showDialog();
    this._isOpen = true;
    if (Dialog.COUNT === 0) {
      EventHandler.trigger(document, Dialog.EVENT.FIRST_OPEN);
      if (Dialog.PREVENT_BODY_SCROLL.open) {
        Dialog.PREVENT_BODY_SCROLL.open();
      }
      EventHandler.trigger(document, Dialog.EVENT.ALL, {
        component: this,
        eventType: Dialog.EVENT.FIRST_OPEN,
      });
    }

    EventHandler.trigger(this._element, Dialog.EVENT.OPEN, {
      component: this,
    });

    EventHandler.trigger(document, Dialog.EVENT.ALL, {
      component: this,
      eventType: Dialog.EVENT.OPEN,
    });
    Dialog.COUNT++;
  }

  _close(e) {
    if (e && e.preventDefault) {
      e.preventDefault();
    }

    this._hideDialog();
    EventHandler.trigger(this._element, Dialog.EVENT.CLOSE, {
      component: this,
    });
    EventHandler.trigger(document, Dialog.EVENT.ALL, {
      component: this,
      eventType: Dialog.EVENT.CLOSE,
    });
    if (this._options.animate !== true) {
      this._hideBackground();
      this._confineTab.destroy();
      this.destroy();
    }
  }

  _showBackground() {
    if (this._bg) {
      document.body.appendChild(this._bg);
      // eslint-disable-next-line no-unused-vars
      const reflow = this._bg.offsetHeight;
      this._bg.classList.add("fadeIn");
    }
  }

  _showDialog() {
    // eslint-disable-next-line no-unused-vars
    const reflow = this._element.offsetHeight;
    if (this._options.animate === true) {
      EventHandler.one(this._element, "animationend", () => {
        const focusable = this._confineTab.init();
        focusable[0].focus();
        EventHandler.trigger(this._element, Dialog.EVENT.OPENED, {
          component: this,
        });
        EventHandler.trigger(document, Dialog.EVENT.ALL, {
          component: this,
          eventType: Dialog.EVENT.OPENED,
        });
      });
    } else {
      this._confineTab.init();
    }
    this._element.classList.add(this._options.openClass);
  }

  _hideBackground() {
    if (this._bg) document.body.removeChild(this._bg);
  }

  _hideDialog() {
    this._element.classList.add(this._options.closeClass);
    this._element.classList.remove(this._options.openClass);
    EventHandler.one(this._element, "animationend", () => {
      this._element.classList.remove(this._options.closeClass);
      this._hideBackground();
      this._confineTab.destroy();
      this.destroy();
    });
  }
}

EventHandler.on(document, `click.DIALOG_TRIGGER`, (event) => {
  const el = event.target.closest(`[${IDENTIFIER.TRIGGER}]`);
  if (!el) return;
  const target = el.getAttribute(IDENTIFIER.TRIGGER);
  if (!el.getAttribute(IDENTIFIER.ARIA_TRIGGER)) {
    console.warn(el, IDENTIFIER.ARIA_TRIGGER, "속성이 누락되었습니다.");
  }
  if (target) {
    const dialogElement = getElement(target);
    if (dialogElement) {
      const dialog = Dialog.get(dialogElement, true);
      dialog.open();
    }
  }
});

export { defaultConfig };
export default Dialog;
